<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"shizhida.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="概述Mysql的查询优化工作是Mysql所有技术中最有用最为立竿见影的一项。通过合理的优化，往往可以令SQL查询的执行效率以数量级的方式提升。 因为网络通信等各种因素的干扰，对于查询时间很难得到一个准确的数值，在本章中所列的查询时间均为一个统计意义的均值，仅供参考，相比之下更重要的是不同查询之间的快慢对比。 本章内容分为三大部分：  执行计划分析 索引优化 关联查询优化  在本章的最开始，默认所有">
<meta property="og:type" content="article">
<meta property="og:title" content="(Mysql) 二、查询优化">
<meta property="og:url" content="http://shizhida.com/mysql/Mysql-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="Aya的技术笔记">
<meta property="og:description" content="概述Mysql的查询优化工作是Mysql所有技术中最有用最为立竿见影的一项。通过合理的优化，往往可以令SQL查询的执行效率以数量级的方式提升。 因为网络通信等各种因素的干扰，对于查询时间很难得到一个准确的数值，在本章中所列的查询时间均为一个统计意义的均值，仅供参考，相比之下更重要的是不同查询之间的快慢对比。 本章内容分为三大部分：  执行计划分析 索引优化 关联查询优化  在本章的最开始，默认所有">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-10-30T03:53:09.000Z">
<meta property="article:modified_time" content="2020-11-03T09:39:16.154Z">
<meta property="article:author" content="Aya Shi">
<meta property="article:tag" content="MYSQL">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://shizhida.com/mysql/Mysql-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>(Mysql) 二、查询优化 | Aya的技术笔记</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?29b79bcfc487303136c79e51d766681d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Aya的技术笔记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://shizhida.com/mysql/Mysql-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/image/icon.png">
      <meta itemprop="name" content="Aya Shi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aya的技术笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          (Mysql) 二、查询优化
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-30 11:53:09" itemprop="dateCreated datePublished" datetime="2020-10-30T11:53:09+08:00">2020-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-03 17:39:16" itemprop="dateModified" datetime="2020-11-03T17:39:16+08:00">2020-11-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mysql/" itemprop="url" rel="index"><span itemprop="name">Mysql</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Mysql的查询优化工作是Mysql所有技术中最有用最为立竿见影的一项。通过合理的优化，往往可以令SQL查询的执行效率以数量级的方式提升。</p>
<p>因为网络通信等各种因素的干扰，对于查询时间很难得到一个准确的数值，在本章中所列的查询时间均为一个统计意义的均值，仅供参考，相比之下更重要的是不同查询之间的快慢对比。</p>
<p>本章内容分为三大部分：</p>
<ul>
<li>执行计划分析</li>
<li>索引优化</li>
<li>关联查询优化</li>
</ul>
<p>在本章的最开始，默认所有的表除主键外没有任何索引。</p>
<p>本章只会讲述优化手段的应用，关于优化的细节原理会在后续进行详解。</p>
<a id="more"></a>

<h2 id="执行计划分析"><a href="#执行计划分析" class="headerlink" title="执行计划分析"></a>执行计划分析</h2><p>执行优化最便捷的一步是先读懂Mysql的执行计划。Mysql提供了<code>explain</code>语句来查看SQL的执行计划。</p>
<p>我们首先来一个简单的案例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 工资在40000-40200之间的工资记录：</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> salaries <span class="keyword">where</span> salary <span class="keyword">between</span> <span class="number">40000</span> <span class="keyword">and</span> <span class="number">40200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 得到结果：</span></span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+---------+----------+-------------+</span></span><br><span class="line">| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows    | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+---------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | salaries  | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 2838629 |    11.11 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+---------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<p>得到的执行计划中各列的含义如下：</p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>表示SQL的执行顺序。若是ID相同，则从上到下按顺序执行，否则按照从大到小的顺序执行。</p>
<h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>表示查询语句的类型，包括九种不同的类型：</p>
<ul>
<li>SIMPLE 简单查询</li>
<li>PRIMARY 若查询中包含有子查询等复杂语句，则外层SELECT会被标记为PRIMARY</li>
<li>UNION UNION语句中的第二个或后面的SELECT语句（第一个是PRIMARY)</li>
<li>DEPENDENT UNION 与上一个相同，当内部条件取决于外部的查询时会会使用该类型</li>
<li>UNION RESULT UNION的结果</li>
<li>SUBQUERY 子查询中的第一个SELECT</li>
<li>DEPENDENT SUBQUERY 子查询中的第一个SELECT，当内部条件取决于外部的查询时会会使用该类型</li>
<li>DERIVED 派生表的SELECT,FROM子句的子查询</li>
<li>UNCACHEABLE SUBQUERY 不能被缓存的子查询</li>
</ul>
<h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>表示当前行的信息是对应某张表的，对于一些子查询中间的派生表，会使用诸如<code>&lt;derived2&gt;</code>的表名。</p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>表示MYSQL在表中查找的方式。常用的有以下几种：</p>
<ul>
<li>ALL: 全表查询，性能最低的一种</li>
<li>index: 全表索引</li>
<li>range: 只检索指定范围</li>
<li>ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</li>
<li>eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</li>
<li>const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量,system是const类型的特例，当查询的表只有一行的情况下，使用system</li>
<li>NULL：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</li>
</ul>
<h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>指出Mysql可能会用到的索引和字段。列出不代表一定会使用。</p>
<h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><p>显示Mysql实际使用的字段（索引）</p>
<h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示索引中使用的字节数，可以计算查询中使用的索引长度，越短越好</p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>表示表之间的连接匹配条件，在子查询中会用到。</p>
<h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>表示Mysql预估会读取的数据行数</p>
<h3 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h3><p>包含以下几种常见的扩展信息：</p>
<ul>
<li>Using where: 使用了Where语句</li>
<li>Using index: 说明查询覆盖了索引</li>
<li>Using temporary: 表示Mysql需要创建临时表来存储结果集</li>
<li>Using filesort: 表示Mysql无法用索引完成排序</li>
<li>Using join buffer: 在join连接中的连接条件没有索引，需要建立连接缓冲区来储存中间结果。</li>
<li>Impossible where: 强调where会导致没有符合条件的行</li>
<li>Select tables optimized away: 在没有GROUP BY子句的情况下，基于索引优化MIN/MAX操作，或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</li>
</ul>
<p>还有更多的扩展信息可以见<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-extra-information">官方文档</a></p>
<h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><p>表示被条件过滤之后会剩余数据的百分比。当<code>filtered=100</code>时说明没有数据会被过滤掉。该值越低说明过滤掉的数据越多。</p>
<hr>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="Mysql的索引类型："><a href="#Mysql的索引类型：" class="headerlink" title="Mysql的索引类型："></a>Mysql的索引类型：</h3><ul>
<li>INDEX 普通索引</li>
<li>UNIQUE 唯一索引，索引列（列的组合）的值必须唯一或为空</li>
<li>PRIMARY 主键索引， 特殊的唯一索引，每个表只能有一个。</li>
<li>FULLTEXT 全文索引，需要配合match against语句来查询。类似于一个查询引擎。需文本可以分词。</li>
<li>SPATIAL 空间索引，对于空间数据类型建立的索引</li>
</ul>
<h3 id="简单索引案例："><a href="#简单索引案例：" class="headerlink" title="简单索引案例："></a>简单索引案例：</h3><p>重看这个执行计划：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 工资在40000-40200之间的工资记录：</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> salaries <span class="keyword">where</span> salary <span class="keyword">between</span> <span class="number">40000</span> <span class="keyword">and</span> <span class="number">40200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 得到结果：</span></span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+---------+----------+-------------+</span></span><br><span class="line">| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows    | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+---------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | salaries  | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 2838629 |    11.11 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+---------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<p>看到这次查询是一个全表查询（<code>type=ALL</code>)，没有用到任何索引，需要查询299700行数据，过滤之后只剩余了11.11%的数据是有用的。现在执行这个SQL的耗时约为1.2秒。</p>
<p>在这种情况下，首先想到的就应该是为查询列增加索引。然后再查看执行计划</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`employees`</span>.<span class="string">`salaries`</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> <span class="string">`salary`</span> <span class="keyword">USING</span> BTREE (<span class="string">`salary`</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> salaries <span class="keyword">where</span> salary <span class="keyword">between</span> <span class="number">40000</span> <span class="keyword">and</span> <span class="number">40200</span>;</span><br><span class="line">+<span class="comment">----+-------------+----------+------------+-------+---------------+--------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line">| id | select_type | table    | partitions | type  | possible_keys | key    | key_len | ref  | rows   | filtered | Extra                    |</span><br><span class="line">+<span class="comment">----+-------------+----------+------------+-------+---------------+--------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | salaries | NULL       | range | salary        | salary | 4       | NULL | 202184 |   100.00 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+-------------+----------+------------+-------+---------------+--------+---------+------+--------+----------+--------------------------+</span></span><br></pre></td></tr></table></figure>

<p>可以看到现在的查询成功应用了刚刚新建的<code>salary</code>索引，查询类型改成了<code>range</code>， 所需查询的行数骤减为202184行。此时执行这一条查询所需的时间约为0.03秒。得到了大幅度的提升。</p>
<p>通过这个案例，已经可以很清晰的看到索引在提升查询效率方面的巨大作用。</p>
<h3 id="字符串索引与模糊查询"><a href="#字符串索引与模糊查询" class="headerlink" title="字符串索引与模糊查询"></a>字符串索引与模糊查询</h3><p>之前的查询都是关于数字、日期的格式化列的查询。在日常使用中，对于字符串列的查询也是很常见的，比如下面这个案例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询所有first_name为Georgy的员工信息：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.employees <span class="keyword">where</span> first_name = <span class="string">&quot;Georgy&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在未添加索引的情况下，这条查询的执行耗时为0.13s，现在为<code>first_name</code>字段增加一个索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`employees`</span>.<span class="string">`employees`</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> <span class="string">`first_name`</span> (<span class="string">`first_name`</span> <span class="keyword">ASC</span>);</span><br></pre></td></tr></table></figure>

<p>其查询效率可以提升至0.02s以下，相比于增加索引之前有了数倍的提升。通过<code>Explain</code>查看执行计划可以看到利用了刚刚创建的索引，查询类型为<code>ref</code>。由此可见索引对于字符串列也同样有效。实际上我们甚至可以对字符串进行对比，比如下面这个查询也同样可以利用这个索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.employees <span class="keyword">where</span> first_name <span class="keyword">between</span> <span class="string">&quot;Georga&quot;</span> <span class="keyword">and</span> <span class="string">&quot;Georgz&quot;</span>;</span><br><span class="line"><span class="comment">-- 这个查询同样利用了索引，查询类型为range。</span></span><br></pre></td></tr></table></figure>

<p>但是我们修改一下查询条件，可能就有所不同了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- A: </span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.employees <span class="keyword">where</span> first_name <span class="keyword">like</span> <span class="string">&quot;Georgy%&quot;</span>;</span><br><span class="line"><span class="comment">-- B: </span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.employees <span class="keyword">where</span> first_name <span class="keyword">like</span> <span class="string">&quot;%Georgy&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这两个查询看似只有一个百分号的差别，但是A的执行速度为0.02s，而B的执行速度为0.15s。对比上面的例子可以很明显的猜到B的查询没有利用索引。通过<code>Explain</code>查看执行计划可以确认这一猜想：A的查询类型为<code>ref</code>，而B的查询类型为<code>ALL</code>。</p>
<p>当我们使用模糊查询时，需要注意左侧的模糊查询不会利用到索引，其查询效率会低很多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：在网上有很多博客说可以用LOCATE或者POSITION函数，或者用reverse之类的方法来利用索引，实际上这些方法在MYSQL 5.7中均不会生效！</span><br><span class="line">使用全文索引可以部分的解决问题，但是全文索引仅限于可以进行分词的文本，对不能分词的连续字符串模糊查询就很无力了。</span><br><span class="line">以目前作者所知，单纯依靠sql优化技术，没有任何方法可以完全功能的实现高效左侧模糊查询。只能通过业务逻辑来进行规避。诸如增加冗余列倒序存储等方式。</span><br></pre></td></tr></table></figure>

<h3 id="组合索引与最左匹配原则"><a href="#组合索引与最左匹配原则" class="headerlink" title="组合索引与最左匹配原则"></a>组合索引与最左匹配原则</h3><p>以上的索引都是对于单个列的索引，在Mysql中还可以对多列建立联合索引。</p>
<p>首先为<code>employees</code>创建一个联合索引<code>nameAndGender</code>，包含了<code>first_name, last_name, gender</code>三个列。然后在表中进行两次查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`employees`</span>.<span class="string">`employees`</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> <span class="string">`nameAndGender`</span> (<span class="string">`first_name`</span> <span class="keyword">ASC</span>, <span class="string">`last_name`</span> <span class="keyword">ASC</span>, <span class="string">`gender`</span> <span class="keyword">ASC</span>);</span><br><span class="line"><span class="comment">-- A：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.employees <span class="keyword">where</span> first_name = <span class="string">&#x27;Kazuhide&#x27;</span> <span class="keyword">and</span> gender = <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line"><span class="comment">-- B：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.employees <span class="keyword">where</span> last_name = <span class="string">&#x27;Cooke&#x27;</span> <span class="keyword">and</span> gender = <span class="string">&#x27;F&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>在实际查询中，查询A的执行耗时约为0.016s，查询B的执行耗时约为0.125s，存在很大差距。查看两个查询的执行计划如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- A:</span></span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+---------------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line">| id | select_type | table     | partitions | type | possible_keys | key           | key_len | ref   | rows | filtered | Extra                 |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+---------------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line">|  1 | SIMPLE      | employees | NULL       | ref  | nameAndGender | nameAndGender | 58      | const |  234 |    50.00 | Using index condition |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+---------------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- B:</span></span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line">| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | employees | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 298740 |     5.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<p>可以看到查询A利用了刚刚创建的<code>nameAndGender</code>索引，而查询B并没有利用索引，进行了全表的查询。</p>
<p>在Mysql的联合索引中，遵循最左匹配原则，即查询条件中必须包含联合索引的最左列才能够利用联合索引。而且只要包含了最左列，不论后面是否连续依次利用其它列，比如跳过<code>last_name</code>直接查询<code>gender</code>，或者直接只查询<code>first_name</code>，均可以成功利用索引。</p>
<h3 id="其它的索引优化小技巧"><a href="#其它的索引优化小技巧" class="headerlink" title="其它的索引优化小技巧"></a>其它的索引优化小技巧</h3><ol>
<li><p>应尽量避免在 where 子句中使用not，&lt;&gt;，!=操作符，或者在索引列上使用函数，否则将引擎放弃使用索引而进行全表扫描。</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">is</span> <span class="literal">null</span></span><br><span class="line"><span class="comment">-- 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li><p>尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">or</span> <span class="keyword">num</span>=<span class="number">20</span>;</span><br><span class="line"><span class="comment">--可以这样查询：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">20</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>in 和 not in 也要慎用，否则会导致全表扫描，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">-- 对于连续的数值，能用 between 就不要用 in 了：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=@<span class="keyword">num</span></span><br><span class="line"><span class="comment">-- 可以改为强制查询使用索引：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">with</span>(<span class="keyword">index</span>(索引名)) <span class="keyword">where</span> <span class="keyword">num</span>=@<span class="keyword">num</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">substring</span>(<span class="keyword">name</span>,<span class="number">1</span>,<span class="number">3</span>)=’abc’; <span class="comment">-- name以abc开头的id</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">datediff</span>(<span class="keyword">day</span>,createdate,’<span class="number">2005</span><span class="number">-11</span><span class="number">-30</span>′)=<span class="number">0</span>; <span class="comment">-- ’2005-11-30′生成的id</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>/<span class="number">2</span>=<span class="number">100</span></span><br><span class="line"><span class="comment">-- 应改为:</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> ‘abc%’</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> createdate&gt;=’<span class="number">2005</span><span class="number">-11</span><span class="number">-30</span>′ <span class="keyword">and</span> createdate&lt;’<span class="number">2005</span><span class="number">-12</span><span class="number">-1</span>′</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">100</span>*<span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>很多时候用 exists 代替 in 是一个好的选择：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">num</span> <span class="keyword">from</span> a <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">in</span>(<span class="keyword">select</span> <span class="keyword">num</span> <span class="keyword">from</span> b)</span><br><span class="line"><span class="comment">-- 用下面的语句替换：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">num</span> <span class="keyword">from</span> a <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> b <span class="keyword">where</span> <span class="keyword">num</span>=a.num)</span><br></pre></td></tr></table></figure>
</li>
<li><p>并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段 sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p>
</li>
<li><p>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。</p>
</li>
</ol>
<hr>
<h2 id="关联表优化"><a href="#关联表优化" class="headerlink" title="关联表优化"></a>关联表优化</h2><p>现在回到第一章中提出的一个问题：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- A:</span></span><br><span class="line"><span class="keyword">select</span> e.* <span class="keyword">from</span> </span><br><span class="line">	employees e, </span><br><span class="line">	(<span class="keyword">select</span> emp_no, salary <span class="keyword">from</span> salaries) s  </span><br><span class="line"><span class="keyword">where</span> e.emp_no = s.emp_no  <span class="keyword">group</span> <span class="keyword">by</span> s.emp_no <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">max</span>(s.salary) <span class="keyword">DESC</span> <span class="keyword">limit</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- B:</span></span><br><span class="line"><span class="keyword">select</span> e.* <span class="keyword">from</span> </span><br><span class="line">	employees e, </span><br><span class="line">	(<span class="keyword">select</span> emp_no, <span class="keyword">max</span>(salary) salary <span class="keyword">from</span> salaries <span class="keyword">group</span> <span class="keyword">by</span> emp_no) s  </span><br><span class="line"><span class="keyword">where</span> e.emp_no = s.emp_no <span class="keyword">order</span> <span class="keyword">by</span> s.salary <span class="keyword">DESC</span> <span class="keyword">limit</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- C:</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employees e <span class="keyword">where</span> e.emp_no <span class="keyword">in</span> </span><br><span class="line">	(<span class="keyword">select</span> sub.emp_no <span class="keyword">from</span> </span><br><span class="line">		(<span class="keyword">select</span> <span class="keyword">DISTINCT</span> emp_no <span class="keyword">from</span> salaries <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">DESC</span> <span class="keyword">limit</span> <span class="number">10</span>)</span><br><span class="line">		<span class="keyword">as</span> sub </span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">在salaries.salary字段增加b-tree索引的情况下，SQL的执行速度如下：</span><br><span class="line">A: 20s</span><br><span class="line">B: 1.2s</span><br><span class="line">C: 0.02s</span><br><span class="line"></span><br><span class="line">问：为何会有这么大的效率差距？</span><br></pre></td></tr></table></figure>

<p>这里面其实有很多重因素的影响，最重要的在于：参与关联表的大小。</p>
<p>首先对比A和B的查询过程</p>
<p>A：表employees有30万行数据，子查询结果表s有280万行数据，需要将30万数据依次与280万数据对比匹配，然后再进行聚合和排序操作。操作量为30*280。</p>
<p>B：表employees有30万行数据，子查询结果表s上进行聚合和排序操作，结果又有30万行数据，需要将30万与30万数据对比匹配。操作量为30*30。</p>
<p>再加上A表的中间表占用空间较大，聚合和排序操作耗时会更多，也就导致了A和B两个查询的效率有很大的差别。</p>
<p>理解了A和B查询的区别，就很容易理解C查询为何会如此之快：</p>
<ol>
<li>C查询不需要做表之间的关联操作，可以省略掉交叉对比的过程。</li>
<li>C查询的子查询充分利用索引，且结果只有10条，效率极高。</li>
<li>在外层查询中利用主键索引提升了查询效率。</li>
</ol>
<p>可以看到通过充分优化关联表和子查询，可以更好地利用索引，大幅度的提升查询效率。</p>
<p>在Mysql的关联表优化中，有一点叫做尽量用小表驱动大表。上面的三个查询充分的验证了这个规则：</p>
<p>查询A中，用了两个很大的表做链接，在最后的大结果集上做了分组和排序，导致效率很低。</p>
<p>查询B中，通过对于表salaries的预先处理，减小了表的大小，有效地提升了效率。</p>
<p>查询C中，单纯对<code>salaries</code>表做了处理，生成了一个仅有10条数据的小表，再次令效率得到了大幅度的提高。</p>
<p>可以看到随着表的大小的减少，尤其是用作查询条件的表的前置处理，可以有效地提升在关联查询中的执行效率。在使用中，应当注意尽量将查询筛选前置，减小参与关联的表的大小。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章内容简述了Mysql中查询优化的基本方法和原则，Mysql的查询优化往往可以带来较好的性能提升，值得引起重视。但是本章仅仅介绍了这些技巧的应用，并没有详细说明原理。在下一章中将会介绍Mysql的一些底层原理，进一步详解优化的机制。</p>
<p>更详细的优化细节可以阅读<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/optimization.html">Mysql官方文档</a>中关于优化的部分。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MYSQL/" rel="tag"># MYSQL</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"># 数据库</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/mysql/Mysql-%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80/" rel="prev" title="(Mysql) 一、查询基础">
      <i class="fa fa-chevron-left"></i> (Mysql) 一、查询基础
    </a></div>
      <div class="post-nav-item">
    <a href="/mysql/Mysql-%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86/" rel="next" title="(Mysql) 三、存储方式和索引原理">
      (Mysql) 三、存储方式和索引原理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%88%86%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">执行计划分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#id"><span class="nav-number">2.1.</span> <span class="nav-text">id</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select-type"><span class="nav-number">2.2.</span> <span class="nav-text">select_type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#table"><span class="nav-number">2.3.</span> <span class="nav-text">table</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type"><span class="nav-number">2.4.</span> <span class="nav-text">type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#possible-keys"><span class="nav-number">2.5.</span> <span class="nav-text">possible_keys</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Key"><span class="nav-number">2.6.</span> <span class="nav-text">Key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#key-len"><span class="nav-number">2.7.</span> <span class="nav-text">key_len</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ref"><span class="nav-number">2.8.</span> <span class="nav-text">ref</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rows"><span class="nav-number">2.9.</span> <span class="nav-text">rows</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#extra"><span class="nav-number">2.10.</span> <span class="nav-text">extra</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#filtered"><span class="nav-number">2.11.</span> <span class="nav-text">filtered</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="nav-number">3.</span> <span class="nav-text">索引优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Mysql%E7%9A%84%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="nav-number">3.1.</span> <span class="nav-text">Mysql的索引类型：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%B4%A2%E5%BC%95%E6%A1%88%E4%BE%8B%EF%BC%9A"><span class="nav-number">3.2.</span> <span class="nav-text">简单索引案例：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2"><span class="nav-number">3.3.</span> <span class="nav-text">字符串索引与模糊查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="nav-number">3.4.</span> <span class="nav-text">组合索引与最左匹配原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E7%9A%84%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="nav-number">3.5.</span> <span class="nav-text">其它的索引优化小技巧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E8%A1%A8%E4%BC%98%E5%8C%96"><span class="nav-number">4.</span> <span class="nav-text">关联表优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">小结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Aya Shi"
      src="/image/icon.png">
  <p class="site-author-name" itemprop="name">Aya Shi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zzbkszd" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zzbkszd" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zzbkszd@163.com" title="E-Mail → mailto:zzbkszd@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Aya Shi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
